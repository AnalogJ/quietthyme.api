# Welcome to Serverless!
#
# This file is the main config file for your service.
# It's very minimal at this point and uses default values.
# You can always add more config options for more control.
# We've included some commented out config examples here.
# Just uncomment any of them to get that config option.
#
# For full config options, check the docs:
#    v1.docs.serverless.com
#
# Happy Coding!

service: quietthyme-api # NOTE: update this with your service name

provider:
  cfLogs: true
  name: aws
  stage: 'beta'
  region: us-east-1
  timeout: 40 # optional, default is 6
  runtime: nodejs4.3
  memorySize: 128

  #these vpc rules are required because we've hardcoded postgres connection during testing.
  #in prod, this will be specified dynamically via cloudformation.
  # because of issues like: https://github.com/serverless/serverless/issues/2780 on first deploy make sure to comment out
  # the vpc section, and uncomment it after a successful deploy.
  iamRoleStatements:
    - Effect: "Allow"
      Action:
        - "ec2:CreateNetworkInterface"
        - "ec2:DescribeNetworkInterfaces"
        - "ec2:DetachNetworkInterface"
        - "ec2:DeleteNetworkInterface"
      Resource: "*"
    - Effect: "Allow"
      Action:
        - "s3:PutObject"
        - "s3:GetObject"
      Resource: "arn:aws:s3:::${self:service}-${opt:stage, self:provider.stage}-*"
#  vpc:
#    securityGroupIds:
#      - sg-bbb818c3
#    subnetIds:
#      - subnet-afea3085
#      - subnet-297de85f

custom:

  # overridden from https://github.com/serverless/serverless/blob/03cc50b246c656183110669126a632735ea46b15/lib/plugins/aws/deploy/compile/events/apiGateway/lib/method/integration.js#L106-L140
  standardRequestTemplate: >-
    #define( $loop )
      {
      #foreach($key in $map.keySet())
          #set( $k = $util.escapeJavaScript($key) )
          #set( $v = $util.escapeJavaScript($map.get($key)).replaceAll("\\\\'", "'") )
          "$k":
            "$v"
            #if( $foreach.hasNext ) , #end
      #end
      }
    #end
    {
      "body": $input.json("$"),
      "method": "$context.httpMethod",
      "principalId": "$context.authorizer.principalId",
      "stage": "$context.stage",
      #set( $map = $input.params().header )
      "headers": $loop,
      #set( $map = $input.params().querystring )
      "query": $loop,
      #set( $map = $input.params().path )
      "path": $loop,
      #set( $map = $context.identity )
      "identity": $loop,
      #set( $map = $stageVariables )
      "stageVariables": $loop,

      "httpMethod": "$context.httpMethod",

      #set( $tokenVal = $input.params().header.get('Authorization').split(' ') )
      #if( $tokenVal.size() == 2 )
        "token": "$tokenVal[1]"
      #else
      "token": ""
      #end
    }
  standardResponseTemplate: "{\"success\":true, \"data\": $input.json('$') }"
  errorResponseTemplate: "#set($inputRoot = $input.path('$.errorMessage')){\"success\":false, \"error\": $inputRoot }"

  standardRequests:
    template:
      application/json: ${self:custom.standardRequestTemplate}

  standardResponses:
    headers:
      Content-Type: "'application/json'"
    template: ${self:custom.standardResponseTemplate}
    statusCodes:
      200:
        pattern: ''
        template:
          application/json: ${self:custom.standardResponseTemplate}
      400:
        template:
          application/json: ${self:custom.errorResponseTemplate}
        pattern: '.*\[400\].*'
      404:
        template:
          application/json: ${self:custom.errorResponseTemplate}
        pattern: '.*\[404\].*'
      500:
        template:
          application/json: ${self:custom.errorResponseTemplate}
        pattern: '.*\[500\].*'

  redirectResponse:
    headers:
      Location: "integration.response.body.headers.Location"
      Content-Type: "'application/json'"
    statusCodes:
      302:
        pattern: ''
        template:
          application/json: "{}"

  catalogResponse:
    headers:
      Content-Type: "'application/xml'"
      Cache-Control: "'max-age=120'"
    template: $input.path('$')
    statusCodes:
      200:
        pattern: ''
        template:
          application/xml: $input.path('$')

  variables:
    master:
      cleanup_enabled: true
    beta:
      cleanup_enabled: false
    DOMAIN: api.quietthyme.com
    DEPLOY_SHA: ${env:CIRCLE_SHA1}
    STAGE: ${opt:stage, self:provider.stage}
    STORAGE_SALT: ${env:${opt:stage, self:provider.stage}_STORAGE_SALT, env:STORAGE_SALT}
    ENCRYPTION_JWT_PASSPHRASE: ${env:${opt:stage, self:provider.stage}_ENCRYPTION_JWT_PASSPHRASE, env:ENCRYPTION_JWT_PASSPHRASE}
    OAUTH_BOX_CLIENT_KEY: ${env:${opt:stage, self:provider.stage}_OAUTH_BOX_CLIENT_KEY, env:OAUTH_BOX_CLIENT_KEY}
    OAUTH_BOX_CLIENT_SECRET: ${env:${opt:stage, self:provider.stage}_OAUTH_BOX_CLIENT_SECRET, env:OAUTH_BOX_CLIENT_SECRET}
    OAUTH_DROPBOX_CLIENT_KEY: ${env:${opt:stage, self:provider.stage}_OAUTH_DROPBOX_CLIENT_KEY, env:OAUTH_DROPBOX_CLIENT_KEY}
    OAUTH_DROPBOX_CLIENT_SECRET: ${env:${opt:stage, self:provider.stage}_OAUTH_DROPBOX_CLIENT_SECRET, env:OAUTH_DROPBOX_CLIENT_SECRET}
    OAUTH_GOOGLE_CLIENT_KEY: ${env:${opt:stage, self:provider.stage}_OAUTH_GOOGLE_CLIENT_KEY, env:OAUTH_GOOGLE_CLIENT_KEY}
    OAUTH_GOOGLE_CLIENT_SECRET: ${env:${opt:stage, self:provider.stage}_OAUTH_GOOGLE_CLIENT_SECRET, env:OAUTH_GOOGLE_CLIENT_SECRET}
    OAUTH_SKYDRIVE_CLIENT_KEY: ${env:${opt:stage, self:provider.stage}_OAUTH_SKYDRIVE_CLIENT_KEY, env:OAUTH_SKYDRIVE_CLIENT_KEY}
    OAUTH_SKYDRIVE_CLIENT_SECRET: ${env:${opt:stage, self:provider.stage}_OAUTH_SKYDRIVE_CLIENT_SECRET, env:OAUTH_SKYDRIVE_CLIENT_SECRET}

    PG_CONNECTION_STRING: ${env:${opt:stage, self:provider.stage}_PG_CONNECTION_STRING, env:PG_CONNECTION_STRING}
    KLOUDLESS_API_ID: ${env:${opt:stage, self:provider.stage}_KLOUDLESS_API_ID, env:KLOUDLESS_API_ID}
    KLOUDLESS_API_KEY: ${env:${opt:stage, self:provider.stage}_KLOUDLESS_API_KEY, env:KLOUDLESS_API_KEY}

  writeEnvVars:
    DOMAIN: ${self:custom.variables.DOMAIN}
    DEPLOY_SHA: ${self:custom.variables.DEPLOY_SHA}
    STAGE: ${self:custom.variables.STAGE}
    STORAGE_SALT: ${self:custom.variables.STORAGE_SALT}
    ENCRYPTION_JWT_PASSPHRASE: ${self:custom.variables.ENCRYPTION_JWT_PASSPHRASE}

    OAUTH_BOX_CLIENT_KEY: ${self:custom.variables.OAUTH_BOX_CLIENT_KEY}
    OAUTH_BOX_CLIENT_SECRET: ${self:custom.variables.OAUTH_BOX_CLIENT_SECRET}
    OAUTH_DROPBOX_CLIENT_KEY: ${self:custom.variables.OAUTH_DROPBOX_CLIENT_KEY}
    OAUTH_DROPBOX_CLIENT_SECRET: ${self:custom.variables.OAUTH_DROPBOX_CLIENT_SECRET}
    OAUTH_GOOGLE_CLIENT_KEY: ${self:custom.variables.OAUTH_GOOGLE_CLIENT_KEY}
    OAUTH_GOOGLE_CLIENT_SECRET: ${self:custom.variables.OAUTH_GOOGLE_CLIENT_SECRET}
    OAUTH_SKYDRIVE_CLIENT_KEY: ${self:custom.variables.OAUTH_SKYDRIVE_CLIENT_KEY}
    OAUTH_SKYDRIVE_CLIENT_SECRET: ${self:custom.variables.OAUTH_SKYDRIVE_CLIENT_SECRET}

    PG_CONNECTION_STRING: ${self:custom.variables.PG_CONNECTION_STRING}
    KLOUDLESS_API_ID: ${self:custom.variables.KLOUDLESS_API_ID}
    KLOUDLESS_API_KEY: ${self:custom.variables.KLOUDLESS_API_KEY}
    DEBUG: knex:*,pool2
    NODE_ENV: production

    # content bucket contains thumbnails and files that will be served directly from S3.
    QUIETTHYME_CONTENT_BUCKET: ${self:service}-${opt:stage, self:provider.stage}-content

    # upload bucket contains files that are temporarily located in S3, and will need to be processed, ie:
    # - files manually uploaded via WebUI
    # - files uploaded by Calibre client
    QUIETTHYME_UPLOAD_BUCKET: ${self:service}-${opt:stage, self:provider.stage}-upload


# you can add packaging information here
package:
  # only the following paths will be included in the resulting artifact which will be uploaded. Without specific include everything in the current folder will be included
  include:
    - src
    - functions
  # The following paths will be excluded from the resulting artifact. If both include and exclude are defined we first apply the include, then the exclude so files are guaranteed to be excluded
  exclude:
    - tmp
    - .git
    - .idea
    - no

functions:
# UNAUTHENTICATED METHODS
  version:
    handler: src/version.handler
    events:
      - http:
          path: version
          method: get
          response: ${self:custom.standardResponses}
          integration: lambda
          cors: true


  hook:
    handler: src/hook.kloudless
    events:
    - http: POST hook/kloudless


# OAUTH connect & callback endpoints

  callback:
    handler: src/link.callback
    timeout: 120
    memorySize: 512
    events:
      - http:
          path: callback/{serviceType}
          method: get
          response: ${self:custom.standardResponses}
          integration: lambda
          cors: true
          request:
            parameters:
              querystrings:
                code: true # code querystring parameter is required.

  connect:
    handler: src/link.connect
    timeout: 120
    memorySize: 512
    events:
      - http:
          path: connect/{serviceType}
          method: get
          response: ${self:custom.standardResponses}
          integration: lambda
          cors: true


# auth methods (login/register/calibre)
  authregister:
    handler: src/auth.register
    events:
      - http:
          path: auth/register
          method: POST
          response: ${self:custom.standardResponses}
          integration: lambda
          cors: true

  authlogin:
    handler: src/auth.login
    events:
      - http:
          path: auth/login
          method: POST
          response: ${self:custom.standardResponses}
          integration: lambda
          cors: true

  authcalibre:
    handler: src/auth.calibre
    events:
      - http:
          path: auth/calibre
          method: POST
          response: ${self:custom.standardResponses}
          integration: lambda
          cors: true

# Authenticated API Methods
  authstatus:
    handler: src/auth.status
    events:
      - http:
          path: auth/status
          method: GET
          request: ${self:custom.standardRequests}
          response: ${self:custom.standardResponses}
          integration: lambda
          cors: true

  bookcreate:
    handler: src/book.create
    events:
      - http:
          path: book
          method: POST
          request: ${self:custom.standardRequests}
          response: ${self:custom.standardResponses}
          integration: lambda
          cors: true

  bookfind:
    handler: src/book.find
    events:
      - http:
          path: book
          method: GET
          request: ${self:custom.standardRequests}
          response: ${self:custom.standardResponses}
          integration: lambda
          cors: true

  bookdestroy:
    handler: src/book.destroy
    events:
      - http:
          path: book/{id}
          method: DELETE
          request: ${self:custom.standardRequests}
          response: ${self:custom.standardResponses}
          integration: lambda
          cors: true

  storagelink:
    handler: src/storage.link
    timeout: 300 #TODO, this should be returned back to default.
    events:
      - http:
          path: storage/link
          method: POST
          request: ${self:custom.standardRequests}
          response: ${self:custom.standardResponses}
          integration: lambda
          cors: true

  storagestatus:
    handler: src/storage.status
    timeout: 120
    memorySize: 128
    events:
      - http:
          path: storage/status
          method: GET
          request: ${self:custom.standardRequests}
          response: ${self:custom.standardResponses}
          integration: lambda
          cors: true

  storagepreparebook:
    handler: src/storage.prepare_book
    timeout: 120
    memorySize: 128
    events:
      - http:
          path: storage/prepare/book
          method: POST
          request: ${self:custom.standardRequests}
          response: ${self:custom.standardResponses}
          integration: lambda
          cors: true

  storagepreparecover:
    handler: src/storage.prepare_cover
    timeout: 120
    memorySize: 128
    events:
      - http:
          path: storage/prepare/cover
          method: POST
          request: ${self:custom.standardRequests}
          response: ${self:custom.standardResponses}
          integration: lambda
          cors: true

  storagedownload:
    handler: src/storage.download
    timeout: 120
    memorySize: 128
    events:
      - http:
          path: storage/{id}
          method: GET
          request: ${self:custom.standardRequests}
          response: ${self:custom.redirectResponse}
          integration: lambda
          cors: true

  # this process runs whenever a book is added to upload bucket.
  # it will then look up the book data in DB and migrate it to the correct
  # storage provider.
  storageprocessbook:
    handler: src/storage.process_book
    events:
      - s3:
          bucket: ${self:service}-${opt:stage, self:provider.stage}-upload
          event: s3:ObjectCreated:*



# the following methods are unauthetnicated, but require a catalogToken.
  catalogindex:
    handler: src/catalog.index
    events:
      - http:
          path: catalog/{catalogToken}
          method: get
          request: ${self:custom.standardRequests}
          response: ${self:custom.catalogResponse}
          integration: lambda

  catalogserieslist:
    handler: src/catalog.series
    events:
    - http:
        path: catalog/{catalogToken}/series/{page}
        method: get
        request: ${self:custom.standardRequests}
        response: ${self:custom.catalogResponse}
        integration: lambda

##  catalogauthors:
##    handler: src/catalog.authors
##    events:
##    - http: GET catalog/{catalogToken}/authors/{page}

  catalogbooklist:
    handler: src/catalog.books
    events:
    - http:
        path: catalog/{catalogToken}/books
        method: get
        request: ${self:custom.standardRequests}
        response: ${self:custom.catalogResponse}
        integration: lambda
    - http:
        path: catalog/{catalogToken}/books/{page}
        method: get
        request: ${self:custom.standardRequests}
        response: ${self:custom.catalogResponse}
        integration: lambda

  catalogrecent:
    handler: src/catalog.recent
    events:
    - http:
        path: catalog/{catalogToken}/recent
        method: get
        request: ${self:custom.standardRequests}
        response: ${self:custom.catalogResponse}
        integration: lambda

  catalogseriesid:
    handler: src/catalog.seriesid
    events:
    - http:
        path: catalog/{catalogToken}/in_series/{seriesId}
        method: get
        request: ${self:custom.standardRequests}
        response: ${self:custom.catalogResponse}
        integration: lambda
    - http:
        path: catalog/{catalogToken}/in_series/{seriesId}/{page}
        method: get
        request: ${self:custom.standardRequests}
        response: ${self:custom.catalogResponse}
        integration: lambda

  catalogauthorid:
    handler: src/catalog.authorid
    events:
    - http:
        path: catalog/{catalogToken}/by_author/{authorId}
        method: get
        request: ${self:custom.standardRequests}
        response: ${self:custom.catalogResponse}
        integration: lambda
    - http:
        path: catalog/{catalogToken}/by_author/{authorId}/{page}
        method: get
        request: ${self:custom.standardRequests}
        response: ${self:custom.catalogResponse}
        integration: lambda


  catalogtagname:
    handler: src/catalog.tagname
    events:
    - http:
        path: catalog/{catalogToken}/tagged_with/{tagName}
        method: get
        request: ${self:custom.standardRequests}
        response: ${self:custom.catalogResponse}
        integration: lambda
    - http:
        path: catalog/{catalogToken}/tagged_with/{tagName}/{page}
        method: get
        request: ${self:custom.standardRequests}
        response: ${self:custom.catalogResponse}
        integration: lambda

  catalogsearchdef:
    handler: src/catalog.searchdefinition
    events:
    - http:
        path: catalog/{catalogToken}/search_definition
        method: get
        request: ${self:custom.standardRequests}
        response: ${self:custom.catalogResponse}
        integration: lambda

  catalogsearchmethod:
    handler: src/catalog.search
    events:
    - http:
        path: catalog/{catalogToken}/search
        method: get
        request: ${self:custom.standardRequests}
        response: ${self:custom.catalogResponse}
        integration: lambda

  catalogbookentry:
    handler: src/catalog.book
    events:
    - http:
        path: catalog/{catalogToken}/book/{bookId}
        method: get
        request: ${self:custom.standardRequests}
        response: ${self:custom.catalogResponse}
        integration: lambda

#  catalogdownload:
#    handler: src/catalog.download
#    events:
#    - http: GET catalog/{catalogToken}/download/{bookId}



# you can add CloudFormation resource templates here
#resources:
#  Resources:
#    NewResource:
#      Type: AWS::S3::Bucket
#      Properties:
#        BucketName: my-new-bucket
#  Outputs:
#     NewOutput:
#       Description: "Description for the output"
#       Value: "Some output value"
resources:
  Resources:
    $ref: ./cloudformation-resources.yaml

plugins:
   - serverless-plugin-write-env-vars